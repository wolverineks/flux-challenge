'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// Special property that only our wrappers will have:
var wrapperMagic = 'redux-keto wrapper';

/**
 * Makes a collection of lazy getters for a key-value state slice.
 * The actual wrapper object inherits from this prototype.
 */
function makeWrapperProto (keys, makeReducer, makeProps) {
  var wrapperProto = Object.create(null);
  var loop = function () {
    var key = list[i];

    var reducer = makeReducer(key);

    Object.defineProperty(wrapperProto, key, {
      configurable: true,
      enumerable: true,
      get: function get () {
        var wrapper = this;
        var stash = wrapper[wrapperMagic];

        // If we are already running, this is a problem!
        if (stash.running[key]) {
          var e = new ReferenceError(
            ("Reducer '" + key + "' depends on its own result")
          );
          e.name = 'ReduxKetoCircularReferenceError';
          throw e
        }
        stash.running[key] = true;

        // Evaluate the reducer:
        try {
          var out = reducer(
            stash.state[key],
            stash.action,
            makeProps(stash.props, wrapper, key),
            makeProps(stash.oldProps, stash.state, key)
          );
          if (out === undefined) {
            throw new TypeError(("Reducer '" + key + "' returned undefined"))
          }
          Object.defineProperty(wrapper, key, {
            configurable: true,
            enumerable: true,
            writable: false,
            value: out
          });
          return out
        } finally {
          stash.running[key] = false;
        }
      }
    });
  };

  for (var i = 0, list = keys; i < list.length; i += 1) loop();

  return wrapperProto
}

/**
 * Makes a lazy wrapper object for a key-value state slice.
 */
function makeWrapper (wrapperProto, state, action, props, oldProps) {
  var wrapper = Object.create(wrapperProto);
  Object.defineProperty(wrapper, wrapperMagic, {
    configurable: true,
    enumerable: false,
    writable: false,
    value: { state: state, action: action, props: props, oldProps: oldProps, running: {} }
  });

  return wrapper
}

/**
 * Flattens a lazy key-value wrapper into a plain-old object
 * with the current state as its properties.
 */
function flattenWrapper (state, wrapper) {
  if ( state === void 0 ) state = {};

  // If it's not a wrapper, we are done:
  if (wrapper === null || wrapper[wrapperMagic] == null) { return wrapper }

  // Diff the old and new states:
  var keys = Object.keys(Object.getPrototypeOf(wrapper));
  var unchanged = Object.keys(state).length === keys.length;
  for (var i = 0, list = keys; i < list.length; i += 1) {
    var key = list[i];

    Object.defineProperty(wrapper, key, {
      configurable: false,
      enumerable: true,
      writable: false,
      value: flattenWrapper(state[key], wrapper[key])
    });
    if (wrapper[key] !== state[key]) {
      unchanged = false;
    }
  }

  // If nothing changed, just return the previous state:
  if (unchanged) { return state }

  delete wrapper[wrapperMagic];
  return wrapper
}

function makePropsDefault (props, peers, id) {
  return props != null ? props : peers
}

/**
 * Combines several reducers into one.
 */
function buildReducer (reducerMap, makeProps) {
  if ( makeProps === void 0 ) makeProps = makePropsDefault;

  // Validate argument types:
  if (typeof reducerMap !== 'object' || reducerMap === null) {
    throw new TypeError('The reducer map must be an object.')
  }
  var keys = Object.keys(reducerMap);
  for (var i = 0, list = keys; i < list.length; i += 1) {
    var key = list[i];

    if (typeof reducerMap[key] !== 'function') {
      throw new TypeError('Reducers must be functions.')
    }
  }

  // Build the wrapper:
  var wrapperProto = makeWrapperProto(keys, function (key) { return reducerMap[key]; }, makeProps);

  // Build the default state:
  var defaultState = {};
  for (var i$1 = 0, list$1 = keys; i$1 < list$1.length; i$1 += 1) {
    var key$1 = list$1[i$1];

    defaultState[key$1] = reducerMap[key$1].defaultState;
  }

  function builtReducer (state, action, props, oldProps) {
    if ( state === void 0 ) state = defaultState;

    var wrapper = makeWrapper(wrapperProto, state, action, props, oldProps);

    // If we are the topmost fat reducer, flatten the wrappers:
    return props == null ? flattenWrapper(state, wrapper) : wrapper
  }
  builtReducer.defaultState = defaultState;

  return builtReducer
}

function filterActionsDefault (action, props) {
  return action
}

function filterPropsDefault (props) {
  return props
}

/**
 * Filters the props and actions going into a fat reducer.
 */
function filterReducer (
  reducer,
  filterAction,
  filterProps
) {
  if ( filterAction === void 0 ) filterAction = filterActionsDefault;
  if ( filterProps === void 0 ) filterProps = filterPropsDefault;

  var defaultState = reducer.defaultState;

  function filteredReducer (state, action, props, oldProps) {
    if ( state === void 0 ) state = defaultState;

    var innerAction = filterAction(action, props);
    var innerProps = filterProps(props);
    var innerOldProps = filterProps(oldProps);

    if (!innerAction) { return state }

    var wrapper = reducer(state, innerAction, innerProps, innerOldProps);

    // If we are the topmost fat reducer, flatten the wrappers:
    return props == null ? flattenWrapper(state, wrapper) : wrapper
  }
  filteredReducer.defaultState = defaultState;

  return filteredReducer
}

function makePropsDefault$1 (props, peers, id) {
  return { peers: peers, id: id }
}

var defaultState = {};

/**
 * Applies a reducer to each item of a list.
 * Each reducer manages its own state slice on behalf of the list item.
 */
function mapReducer (reducer, listIds, makeProps) {
  if ( makeProps === void 0 ) makeProps = makePropsDefault$1;

  function mapReducer (state, action, props, oldProps) {
    if ( state === void 0 ) state = defaultState;

    var ids = listIds(props);

    // Try to recycle our wrapper prototype, if possible:
    var wrapperProto =
      state === defaultState || ids !== listIds(oldProps)
        ? makeWrapperProto(ids, function (id) { return reducer; }, makeProps)
        : Object.getPrototypeOf(state);

    var wrapper = makeWrapper(wrapperProto, state, action, props, oldProps);

    // If we are the topmost fat reducer, flatten the wrappers:
    return props == null ? flattenWrapper(state, wrapper) : wrapper
  }
  mapReducer.defaultState = defaultState;

  return mapReducer
}

/**
 * Creates a memoized reducer for derived values.
 * The first aguments are argument filters,
 * which take the props and return an argument to pass to the derivation.
 * The reducer will only run if some of its arguments are not equal ('===').
 */
function memoizeReducer () {
  var arguments$1 = arguments;

  var i = arguments.length - 1;
  var reducer = arguments[i];
  var filters = [];
  while (i-- > 0) { filters[i] = arguments$1[i]; }

  // Type-check the arguments:
  if (typeof reducer !== 'function') {
    throw new TypeError('The reducer must be a function')
  }
  for (var i$1 = 0, list = filters; i$1 < list.length; i$1 += 1) {
    var filter = list[i$1];

    if (typeof filter !== 'function') {
      throw new TypeError('Each argument filter must be a function')
    }
  }

  return function memoizedReducer (
    state,
    action,
    props,
    oldProps
  ) {
    if ( state === void 0 ) state = reducer.defaultState;

    var clean = true;
    var args = [];
    for (var i = 0; i < filters.length; ++i) {
      args[i] = filters[i](props);
      if (clean && args[i] !== filters[i](oldProps)) { clean = false; }
    }

    return clean ? state : reducer.apply(void 0, args)
  }
}

exports.buildReducer = buildReducer;
exports.filterReducer = filterReducer;
exports.mapReducer = mapReducer;
exports.memoizeReducer = memoizeReducer;
//# sourceMappingURL=redux-keto.js.map
