{"version":3,"file":"redux-pixies.js","sources":["../src/enhancers/tamePixie.js","../src/enhancers/catchPixieError.js","../src/enhancers/reflectPixieOutput.js","../src/managers/startPixie.js","../src/managers/attachPixie.js","../src/managers/combinePixies.js","../src/managers/util.js","../src/managers/filterPixie.js","../src/managers/mapPixie.js","../src/enhancers/classPixie.js","../src/redux-pixies.js"],"sourcesContent":["// @flow\nimport type {\n  Condition,\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  UpdateFunction,\n  WildPixie,\n  PixieInput\n} from '../redux-pixies.js'\n\nfunction makePixieShutdownError () {\n  const e = new Error('Pixie has been destroyed')\n  e.name = 'PixieShutdownError'\n  return e\n}\n\nexport function isPixieShutdownError (e: any) {\n  return e instanceof Error && e.name === 'PixieShutdownError'\n}\n\n/**\n * If a wild pixie returns a bare function, turn that into a proper object.\n */\nfunction fixInstance<P> (\n  instance: PixieInstance<P> | UpdateFunction<P>\n): PixieInstance<P> {\n  if (typeof instance === 'function') {\n    return { update: instance, destroy () {} }\n  }\n  return instance\n}\n\n/**\n * Catches synchronous errors and sends them through `onError`,\n * terminating the inner pixie in response. Also prevents `update`\n * from running in parallel if if returns a promise.\n */\nexport function babysitPixie<P> (wildPixie: WildPixie<P>): TamePixie<P> {\n  function outPixie (input: TamePixieInput) {\n    let instance: PixieInstance<P> | void\n    let propsCache: P\n    let propsDirty: boolean = true\n    let updating: boolean = false\n    let destroyed: boolean = false\n    let nextPromise: Promise<P> | void\n    let rejector: ((e: any) => void) | void\n    let resolver: ((props: P) => void) | void\n\n    function destroy () {\n      if (instance) {\n        try {\n          if (rejector) {\n            const copy = rejector\n            nextPromise = void 0\n            rejector = void 0\n            resolver = void 0\n            copy(makePixieShutdownError())\n          }\n          const copy = instance\n          instance = void 0\n          copy.destroy()\n        } catch (e) {\n          onError(e)\n        }\n        destroyed = true\n      }\n    }\n\n    // Ignore any callbacks once `destroy` has completed:\n    function onError (e: Error) {\n      if (!destroyed) input.onError(e)\n      destroy()\n    }\n\n    function onOutput (data: any) {\n      if (!destroyed) input.onOutput(data)\n    }\n\n    function onUpdateDone () {\n      updating = false\n      tryUpdate()\n    }\n\n    function tryUpdate () {\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (instance && propsDirty && !updating) {\n        propsDirty = false\n        updating = true\n\n        try {\n          const thenable = instance.update(propsCache)\n          if (thenable && typeof thenable.then === 'function') {\n            thenable.then(onUpdateDone, onError)\n          } else {\n            updating = false\n          }\n        } catch (e) {\n          onError(e)\n        }\n      }\n    }\n\n    function getNextPromise (): Promise<P> {\n      if (!nextPromise) {\n        nextPromise = new Promise((resolve, reject) => {\n          resolver = resolve\n          rejector = reject\n        })\n      }\n      return nextPromise\n    }\n\n    const childInput: PixieInput<P> = {\n      onError,\n      onOutput,\n      get props () {\n        return propsCache\n      },\n      nextProps: getNextPromise,\n      waitFor<R> (condition: Condition<P, R>): Promise<R> {\n        return new Promise((resolve, reject) => {\n          function checkProps (props: P) {\n            const result = condition(props)\n            if (result != null) resolve(result)\n            else getNextPromise().then(checkProps, reject)\n          }\n          return checkProps(propsCache)\n        })\n      }\n    }\n    try {\n      instance = fixInstance(wildPixie(childInput))\n    } catch (e) {\n      onError(e)\n    }\n\n    return {\n      update (props: P) {\n        propsCache = props\n        propsDirty = true\n\n        // Update the `nextProps` promise right away:\n        if (resolver) {\n          const copy = resolver\n          nextPromise = void 0\n          rejector = void 0\n          resolver = void 0\n          copy(props)\n        }\n\n        tryUpdate()\n      },\n\n      destroy\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = wildPixie.defaultOutput\n  return outPixie\n}\n\n/**\n * Accepts a hand-written reducer, and hardens it with error checking.\n */\nexport function tamePixie<P> (pixie: WildPixie<P>): TamePixie<P> {\n  return pixie.tame ? (pixie: any) : babysitPixie(pixie)\n}\n","// @flow\nimport type {\n  OnError,\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  WildPixie\n} from '../redux-pixies.js'\nimport { tamePixie } from './tamePixie.js'\n\ntype ErrorHandler<P> = (e: any, props: P, onError: OnError) => void\n\nfunction defaultErrorHandler (e: any, props: any, onError: OnError) {\n  onError(e)\n}\n\n/**\n * Intercepts `onError`, shutting down the inner pixie.\n */\nexport function catchPixieError<P: {}> (\n  pixie: WildPixie<P>,\n  errorHandler: ErrorHandler<P> = defaultErrorHandler\n): TamePixie<P> {\n  const tamedPixie = tamePixie(pixie)\n\n  function outPixie (input: TamePixieInput) {\n    const { onOutput } = input\n    let instance: PixieInstance<P> | void\n    let propsCache: P\n\n    const destroy = () => {\n      const copy = instance\n      instance = void 0\n      if (copy) copy.destroy()\n    }\n\n    function onError (e: any) {\n      destroy()\n      try {\n        errorHandler(e, propsCache, input.onError)\n      } catch (e) {\n        input.onError(e)\n      }\n    }\n\n    const childInput: TamePixieInput = { onError, onOutput }\n\n    return {\n      update (props: P) {\n        propsCache = props\n        if (!instance) instance = tamedPixie(childInput)\n        instance.update(props)\n      },\n\n      destroy\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = pixie.defaultOutput\n  return outPixie\n}\n","// @flow\nimport type {\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  WildPixie\n} from '../redux-pixies.js'\nimport { tamePixie } from './tamePixie.js'\n\n/**\n * Copies the `output` back into the pixie as a prop.\n */\nexport function reflectPixieOutput<P: {}> (pixie: WildPixie<P>): TamePixie<P> {\n  const tamedPixie = tamePixie(pixie)\n\n  function outPixie (input: TamePixieInput) {\n    const { onError } = input\n    let instance: PixieInstance<P> | void\n    let output: any = pixie.defaultOutput\n    let propsCache: P\n    let propsDirty: boolean = true\n    let updating: boolean = false\n\n    const tryUpdate = () => {\n      // The `update` function can call `onOutput` or `onError`, so loop:\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (instance && propsDirty && !updating) {\n        propsDirty = false\n        updating = true\n        instance.update({ ...propsCache, output })\n        updating = false\n      }\n    }\n\n    const onOutput = (data: any) => {\n      if (data !== output) {\n        output = data\n        propsDirty = true\n        input.onOutput(data)\n        tryUpdate()\n      }\n    }\n\n    const childInput: TamePixieInput = { onError, onOutput }\n    return {\n      update (props: P) {\n        propsCache = props\n        propsDirty = true\n        if (!instance) instance = tamedPixie(childInput)\n        tryUpdate()\n      },\n\n      destroy () {\n        const copy = instance\n        instance = void 0\n        if (copy) copy.destroy()\n      }\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = pixie.defaultOutput\n  return outPixie\n}\n","// @flow\nimport type {\n  OnError,\n  OnOutput,\n  PixieInstance,\n  WildPixie\n} from '../redux-pixies.js'\nimport { catchPixieError } from '../enhancers/catchPixieError.js'\nimport { reflectPixieOutput } from '../enhancers/reflectPixieOutput.js'\n\nfunction defaultOnError (e: any) {}\nfunction defaultOnOutput (data: any) {}\n\n/**\n * Instantiates a pixie object.\n */\nexport function startPixie<P: {}> (\n  pixie: WildPixie<P>,\n  onError: OnError = defaultOnError,\n  onOutput: OnOutput = defaultOnOutput\n): PixieInstance<P> {\n  return catchPixieError(reflectPixieOutput(pixie))({ onError, onOutput })\n}\n","// @flow\nimport type { OnError, OnOutput, WildPixie } from '../redux-pixies.js'\nimport { startPixie } from './startPixie.js'\nimport type { Store, Dispatch } from 'redux'\n\nexport interface ReduxProps<S, A> {\n  dispatch: Dispatch<A>,\n  output: any,\n  state: S\n}\n\n/**\n * Instantiates a pixie object and attaches it to a redux store.\n */\nexport function attachPixie<S, A> (\n  store: Store<S, A>,\n  pixie: WildPixie<ReduxProps<S, A>>,\n  onError?: OnError,\n  onOutput?: OnOutput\n) {\n  const instance = startPixie(pixie, onError, onOutput)\n  instance.update({\n    dispatch: store.dispatch,\n    output: void 0,\n    state: store.getState()\n  })\n\n  const unsubscribe = store.subscribe(() => {\n    instance.update({\n      dispatch: store.dispatch,\n      output: void 0,\n      state: store.getState()\n    })\n  })\n\n  return () => {\n    unsubscribe()\n    instance.destroy()\n  }\n}\n","// @flow\nimport { tamePixie } from '../enhancers/tamePixie.js'\nimport type {\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  WildPixie\n} from '../redux-pixies.js'\n\n/**\n * Combines one or more pixies into one.\n */\nexport function combinePixies<P> (pixieMap: {\n  [id: string]: WildPixie<P>\n}): TamePixie<P> {\n  const defaultOutput = {}\n  for (const id of Object.keys(pixieMap)) {\n    defaultOutput[id] = pixieMap[id].defaultOutput\n  }\n\n  function outPixie (input: TamePixieInput) {\n    const { onError } = input\n    const childInputs: { [id: string]: TamePixieInput } = {}\n    const instances: { [id: string]: PixieInstance<P> } = {}\n    let outputs: { [id: string]: any } = { ...defaultOutput }\n    let destroyed: boolean = false\n\n    for (const id of Object.keys(pixieMap)) {\n      const onOutput = (data: any) => {\n        if (data !== outputs[id]) {\n          outputs = { ...outputs }\n          outputs[id] = data\n          input.onOutput(outputs)\n        }\n      }\n      childInputs[id] = { onError, onOutput }\n      instances[id] = tamePixie(pixieMap[id])(childInputs[id])\n      if (destroyed) break\n    }\n\n    return {\n      update (props: P) {\n        for (const id of Object.keys(instances)) {\n          instances[id].update(props)\n          if (destroyed) return\n        }\n      },\n\n      destroy () {\n        destroyed = true\n        for (const id of Object.keys(instances)) {\n          instances[id].destroy()\n        }\n      }\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = defaultOutput\n  return outPixie\n}\n","// @flow\nimport type { OnError } from '../redux-pixies.js'\n\n/**\n * If the function throws, send that through `onError`.\n */\nexport function catchify<R> (\n  f: (...args: any) => R,\n  onError: OnError\n): (...args: any) => R | void {\n  return (...args: any) => {\n    try {\n      return f(...args)\n    } catch (e) {\n      onError(e)\n    }\n  }\n}\n\n/**\n * Returns true if two Javascript values are equal (non-recursively).\n */\nexport function shallowCompare<A, B> (a: A, b: B): boolean {\n  if (a === b) return true\n\n  // Fast path for primitives:\n  if (typeof a !== 'object') return false\n  if (typeof b !== 'object') return false\n\n  // Filter out `null`:\n  if (!a || !b) return false\n\n  const keys = Object.getOwnPropertyNames(a)\n  if (keys.length !== Object.getOwnPropertyNames(b).length) return false\n\n  // We know that both objects have the same number of properties,\n  // so if every property in `a` has a matching property in `b`,\n  // the objects must be identical, regardless of key order.\n  for (const key: string of keys) {\n    if (!b.hasOwnProperty(key) || a[key] !== b[key]) return false\n  }\n  return true\n}\n","// @flow\nimport { tamePixie } from '../enhancers/tamePixie.js'\nimport type {\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  WildPixie\n} from '../redux-pixies.js'\nimport { catchify, shallowCompare } from './util.js'\n\n/**\n * Filters the props going into a pixie.\n */\nexport function filterPixie<P, Q> (\n  pixie: WildPixie<Q>,\n  filter: (props: P) => Q | void\n): TamePixie<P> {\n  const tamedPixie = tamePixie(pixie)\n\n  function outPixie (input: TamePixieInput) {\n    const { onError, onOutput } = input\n    let instance: PixieInstance<Q> | void\n    let propsCache: Q | void\n    let destroyed: boolean = false\n\n    const safeFilter = catchify(filter, onError)\n\n    const childInput: TamePixieInput = { onError, onOutput }\n\n    return {\n      update (props: P) {\n        const innerProps = safeFilter(props)\n        if (destroyed) return\n        const dirty = !shallowCompare(innerProps, propsCache)\n        propsCache = innerProps\n\n        // Start or stop the instance:\n        if (innerProps) {\n          if (!instance) instance = tamedPixie(childInput)\n          if (destroyed) return\n          if (dirty) instance.update(innerProps)\n        } else {\n          if (instance) instance.destroy()\n          instance = void 0\n        }\n      },\n\n      destroy () {\n        destroyed = true\n        if (instance) instance.destroy()\n        instance = void 0\n      }\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = pixie.defaultOutput\n  return outPixie\n}\n","// @flow\nimport { tamePixie } from '../enhancers/tamePixie.js'\nimport type {\n  PixieInstance,\n  TamePixie,\n  TamePixieInput,\n  WildPixie\n} from '../redux-pixies.js'\nimport { catchify, shallowCompare } from './util.js'\n\n/**\n * Combines one or more pixies into one, using a list of keys.\n */\nexport function mapPixie<P, Q> (\n  pixie: WildPixie<Q>,\n  listIds: (props: P) => Array<string>,\n  filter: (props: P, id: string) => Q | void\n): TamePixie<P> {\n  const tamedPixie = tamePixie(pixie)\n\n  function outPixie (input: TamePixieInput) {\n    const { onError } = input\n    let instances: { [id: string]: PixieInstance<Q> } = {}\n    let outputs: { [id: string]: any } = {}\n    let outputsDirty: boolean = false\n    const propsCache: { [id: string]: Q | void } = {}\n    let updating: boolean = false\n    let destroyed: boolean = false\n\n    const safeListIds = catchify(listIds, onError)\n    const safeFilter = catchify(filter, onError)\n\n    const updateOutputs = () => {\n      if (outputsDirty && !updating) {\n        outputsDirty = false\n        const newOutputs = {}\n        for (const id of Object.keys(instances)) {\n          newOutputs[id] = outputs[id]\n        }\n        outputs = newOutputs\n        input.onOutput(outputs)\n      }\n    }\n\n    return {\n      update (outerProps: P) {\n        const ids = safeListIds(outerProps)\n        if (destroyed || !ids) return\n\n        // Update or create instances for all keys:\n        updating = true\n        const newInstances: { [id: string]: PixieInstance<Q> } = {}\n        for (const id of ids) {\n          const innerProps = safeFilter(outerProps, id)\n          if (destroyed) return\n          const dirty = !shallowCompare(innerProps, propsCache[id])\n          propsCache[id] = innerProps\n\n          if (innerProps) {\n            if (!instances[id]) {\n              const onOutput = (data: any) => {\n                if (data !== outputs[id]) {\n                  outputs[id] = data\n                  outputsDirty = true\n                  updateOutputs()\n                }\n              }\n              instances[id] = tamedPixie({ onError, onOutput })\n              if (destroyed) return\n            }\n            if (dirty) instances[id].update(innerProps)\n            if (destroyed) return\n            newInstances[id] = instances[id]\n          }\n        }\n\n        // Swap out the instance list, removing unwanted pixies:\n        const oldInstances = instances\n        instances = newInstances\n\n        // Destroy any old instances that are not on the list.\n        // We need to finish this even if it triggers `destroyed`:\n        for (const id of Object.keys(oldInstances)) {\n          if (!newInstances[id]) oldInstances[id].destroy()\n        }\n        if (destroyed) return\n\n        updating = false\n        updateOutputs()\n      },\n\n      destroy () {\n        destroyed = true\n        for (const id of Object.keys(instances)) {\n          if (instances[id]) instances[id].destroy()\n        }\n      }\n    }\n  }\n  outPixie.tame = true\n  outPixie.defaultOutput = {}\n  return outPixie\n}\n","// @flow\nimport type {\n  OnError,\n  OnOutput,\n  TamePixie,\n  PixieInput\n} from '../redux-pixies.js'\nimport { tamePixie } from './tamePixie.js'\n\nexport interface PixieCallbacks {\n  onError: OnError,\n  onOutput: OnOutput\n}\n\n/**\n * Class-style pixies should inherit from this type.\n */\nexport class Pixie<P> {\n  props: P\n\n  constructor (props: P, callbacks?: PixieCallbacks) {\n    this.props = props\n  }\n\n  /**\n   * Called every time the props change.\n   */\n  update (props: P, callbacks: PixieCallbacks): Promise<any> | void {}\n\n  /**\n   * Called before the pixie is destroyed.\n   * This is a great place to clean up any resources.\n   */\n  destroy (props: P, callbacks: PixieCallbacks) {}\n}\n\n/**\n * Turns a class-style pixie into a tame pixie.\n */\nexport function tameClassPixie<P> (Constructor: Class<Pixie<P>>): TamePixie<P> {\n  return tamePixie(({ onError, onOutput }: PixieInput<P>) => {\n    const callbacks: PixieCallbacks = { onError, onOutput }\n    let instance: Pixie<P>\n    let propsCache: P\n\n    return {\n      update (props: P) {\n        propsCache = props\n        if (!instance) {\n          instance = new Constructor(props, callbacks)\n        }\n        return instance.update(props, callbacks)\n      },\n\n      destroy () {\n        return instance.destroy(propsCache, callbacks)\n      }\n    }\n  })\n}\n","// @flow\nexport type OnError = (e: any) => void\nexport type OnOutput = (data: any) => void\nexport type UpdateFunction<P> = (props: P) => any\nexport type DestroyFunction = () => void\n\nexport type Condition<P, R> = (props: P) => R | void\n\nexport interface PixieInstance<P> {\n  update(props: P): any,\n  destroy(): void\n}\n\nexport interface TamePixieInput {\n  onError: OnError,\n  onOutput: OnOutput\n}\n\nexport type TamePixie<P> = (input: TamePixieInput) => PixieInstance<P>\n\nexport interface PixieInput<P> extends TamePixieInput {\n  nextProps(): Promise<P>,\n  +props: P,\n  waitFor<R>(condition: Condition<P, R>): Promise<R>\n}\n\nexport type WildPixie<P> = (\n  input: PixieInput<P>\n) => PixieInstance<P> | UpdateFunction<P>\n\n// Pixie enhancers:\nexport { catchPixieError } from './enhancers/catchPixieError.js'\nexport { reflectPixieOutput } from './enhancers/reflectPixieOutput.js'\nexport { tamePixie, isPixieShutdownError } from './enhancers/tamePixie.js'\n\n// Pixie managers:\nexport { attachPixie } from './managers/attachPixie.js'\nexport type { ReduxProps } from './managers/attachPixie.js'\nexport { startPixie } from './managers/startPixie.js'\nexport { combinePixies } from './managers/combinePixies.js'\nexport { filterPixie } from './managers/filterPixie.js'\nexport { mapPixie } from './managers/mapPixie.js'\n\n// Legacy stuff\nexport { Pixie, tameClassPixie } from './enhancers/classPixie.js'\nexport type { PixieCallbacks } from './enhancers/classPixie.js'\n\n/**\n * Update functions can return this to stop all future updates.\n */\nexport const stopUpdates = { then () {} }\n"],"names":["makePixieShutdownError","e","Error","name","isPixieShutdownError","fixInstance","instance","update","destroy","babysitPixie","wildPixie","outPixie","input","propsCache","propsDirty","updating","destroyed","nextPromise","rejector","resolver","copy","onError","onOutput","data","onUpdateDone","tryUpdate","thenable","then","getNextPromise","Promise","resolve","reject","childInput","props","condition","checkProps","result","tame","defaultOutput","tamePixie","pixie","defaultErrorHandler","catchPixieError","errorHandler","tamedPixie","reflectPixieOutput","output","defaultOnError","defaultOnOutput","startPixie","attachPixie","store","dispatch","getState","unsubscribe","subscribe","combinePixies","pixieMap","Object","keys","id","childInputs","instances","outputs","catchify","f","shallowCompare","a","b","getOwnPropertyNames","length","key","hasOwnProperty","filterPixie","filter","safeFilter","innerProps","dirty","mapPixie","listIds","outputsDirty","safeListIds","updateOutputs","newOutputs","outerProps","ids","newInstances","oldInstances","Pixie","callbacks","tameClassPixie","Constructor","stopUpdates"],"mappings":";;;;AAWA,SAASA,sBAAT,GAAmC;MAC3BC,IAAI,IAAIC,KAAJ,CAAU,0BAAV,CAAV;IACEC,IAAF,GAAS,oBAAT;SACOF,CAAP;;;;AAGF,AAAO,SAASG,oBAAT,CAA+BH,CAA/B,EAAuC;SACrCA,aAAaC,KAAb,IAAsBD,EAAEE,IAAF,KAAW,oBAAxC;;;;;;AAMF,SAASE,WAAT,CACEC,QADF,EAEoB;MACd,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;WAC3B,EAAEC,QAAQD,QAAV,EAAoBE,OAApB,qBAA+B;KAAtC;;SAEKF,QAAP;;;;;;;;AAQF,AAAO,SAASG,YAAT,CAA0BC,SAA1B,EAAiE;WAC7DC,QAAT,CAAmBC,KAAnB,EAA0C;QACpCN,iBAAJ;QACIO,mBAAJ;QACIC,aAAsB,IAA1B;QACIC,WAAoB,KAAxB;QACIC,YAAqB,KAAzB;QACIC,oBAAJ;QACIC,iBAAJ;QACIC,iBAAJ;;aAESX,OAAT,GAAoB;UACdF,QAAJ,EAAc;YACR;cACEY,QAAJ,EAAc;gBACNE,QAAOF,QAAb;0BACc,KAAK,CAAnB;uBACW,KAAK,CAAhB;uBACW,KAAK,CAAhB;kBACKlB,wBAAL;;cAEIoB,OAAOd,QAAb;qBACW,KAAK,CAAhB;eACKE,OAAL;SAVF,CAWE,OAAOP,CAAP,EAAU;kBACFA,CAAR;;oBAEU,IAAZ;;;;;aAKKoB,OAAT,CAAkBpB,CAAlB,EAA4B;UACtB,CAACe,SAAL,EAAgBJ,MAAMS,OAAN,CAAcpB,CAAd;;;;aAITqB,QAAT,CAAmBC,IAAnB,EAA8B;UACxB,CAACP,SAAL,EAAgBJ,MAAMU,QAAN,CAAeC,IAAf;;;aAGTC,YAAT,GAAyB;iBACZ,KAAX;;;;aAIOC,SAAT,GAAsB;;aAEbnB,YAAYQ,UAAZ,IAA0B,CAACC,QAAlC,EAA4C;qBAC7B,KAAb;mBACW,IAAX;;YAEI;cACIW,WAAWpB,SAASC,MAAT,CAAgBM,UAAhB,CAAjB;cACIa,YAAY,OAAOA,SAASC,IAAhB,KAAyB,UAAzC,EAAqD;qBAC1CA,IAAT,CAAcH,YAAd,EAA4BH,OAA5B;WADF,MAEO;uBACM,KAAX;;SALJ,CAOE,OAAOpB,CAAP,EAAU;kBACFA,CAAR;;;;;aAKG2B,cAAT,GAAuC;UACjC,CAACX,WAAL,EAAkB;sBACF,IAAIY,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;qBAClCD,OAAX;qBACWC,MAAX;SAFY,CAAd;;aAKKd,WAAP;;;QAGIe,aAA4B;sBAAA;wBAAA;UAG5BC,KAAJ,GAAa;eACJpB,UAAP;OAJ8B;iBAMrBe,cANqB;aAAA,mBAOpBM,SAPoB,EAOoB;eAC3C,IAAIL,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;mBAC7BI,UAAT,CAAqBF,KAArB,EAA+B;gBACvBG,SAASF,UAAUD,KAAV,CAAf;gBACIG,UAAU,IAAd,EAAoBN,QAAQM,MAAR,EAApB,KACKR,iBAAiBD,IAAjB,CAAsBQ,UAAtB,EAAkCJ,MAAlC;;iBAEAI,WAAWtB,UAAX,CAAP;SANK,CAAP;;KARJ;QAkBI;iBACSR,YAAYK,UAAUsB,UAAV,CAAZ,CAAX;KADF,CAEE,OAAO/B,CAAP,EAAU;cACFA,CAAR;;;WAGK;YAAA,kBACGgC,KADH,EACa;qBACHA,KAAb;qBACa,IAAb;;;YAGId,QAAJ,EAAc;cACNC,OAAOD,QAAb;wBACc,KAAK,CAAnB;qBACW,KAAK,CAAhB;qBACW,KAAK,CAAhB;eACKc,KAAL;;;;OAXC;;;;KAAP;;WAoBOI,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyB5B,UAAU4B,aAAnC;SACO3B,QAAP;;;;;;AAMF,AAAO,SAAS4B,SAAT,CAAuBC,KAAvB,EAA0D;SACxDA,MAAMH,IAAN,GAAcG,KAAd,GAA4B/B,aAAa+B,KAAb,CAAnC;;;AC1JF,SAASC,mBAAT,CAA8BxC,CAA9B,EAAsCgC,KAAtC,EAAkDZ,OAAlD,EAAoE;UAC1DpB,CAAR;;;;;;AAMF,AAAO,SAASyC,eAAT,CACLF,KADK,EAGS;MADdG,YACc,uEADkBF,mBAClB;;MACRG,aAAaL,UAAUC,KAAV,CAAnB;;WAES7B,QAAT,CAAmBC,KAAnB,EAA0C;QAChCU,QADgC,GACnBV,KADmB,CAChCU,QADgC;;QAEpChB,iBAAJ;QACIO,mBAAJ;;QAEML,UAAU,SAAVA,OAAU,GAAM;UACdY,OAAOd,QAAb;iBACW,KAAK,CAAhB;UACIc,IAAJ,EAAUA,KAAKZ,OAAL;KAHZ;;aAMSa,OAAT,CAAkBpB,CAAlB,EAA0B;;UAEpB;qBACWA,CAAb,EAAgBY,UAAhB,EAA4BD,MAAMS,OAAlC;OADF,CAEE,OAAOpB,CAAP,EAAU;cACJoB,OAAN,CAAcpB,CAAd;;;;QAIE+B,aAA6B,EAAEX,gBAAF,EAAWC,kBAAX,EAAnC;;WAEO;YAAA,kBACGW,KADH,EACa;qBACHA,KAAb;YACI,CAAC3B,QAAL,EAAeA,WAAWsC,WAAWZ,UAAX,CAAX;iBACNzB,MAAT,CAAgB0B,KAAhB;OAJG;;;;KAAP;;WAUOI,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyBE,MAAMF,aAA/B;SACO3B,QAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDF;;;;AAGA,AAAO,SAASkC,kBAAT,CAAoCL,KAApC,EAAuE;MACtEI,aAAaL,UAAUC,KAAV,CAAnB;;WAES7B,QAAT,CAAmBC,KAAnB,EAA0C;QAChCS,OADgC,GACpBT,KADoB,CAChCS,OADgC;;QAEpCf,iBAAJ;QACIwC,SAAcN,MAAMF,aAAxB;QACIzB,mBAAJ;QACIC,aAAsB,IAA1B;QACIC,WAAoB,KAAxB;;QAEMU,YAAY,SAAZA,SAAY,GAAM;;;aAGfnB,YAAYQ,UAAZ,IAA0B,CAACC,QAAlC,EAA4C;qBAC7B,KAAb;mBACW,IAAX;iBACSR,MAAT,cAAqBM,UAArB,IAAiCiC,cAAjC;mBACW,KAAX;;KAPJ;;QAWMxB,WAAW,SAAXA,QAAW,CAACC,IAAD,EAAe;UAC1BA,SAASuB,MAAb,EAAqB;iBACVvB,IAAT;qBACa,IAAb;cACMD,QAAN,CAAeC,IAAf;;;KAJJ;;QASMS,aAA6B,EAAEX,gBAAF,EAAWC,kBAAX,EAAnC;WACO;YAAA,kBACGW,KADH,EACa;qBACHA,KAAb;qBACa,IAAb;YACI,CAAC3B,QAAL,EAAeA,WAAWsC,WAAWZ,UAAX,CAAX;;OAJZ;aAAA,qBAQM;YACHZ,OAAOd,QAAb;mBACW,KAAK,CAAhB;YACIc,IAAJ,EAAUA,KAAKZ,OAAL;;KAXd;;WAeO6B,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyBE,MAAMF,aAA/B;SACO3B,QAAP;;;ACnDF,SAASoC,cAAT,CAAyB9C,CAAzB,EAAiC;AACjC,SAAS+C,eAAT,CAA0BzB,IAA1B,EAAqC;;;;;AAKrC,AAAO,SAAS0B,UAAT,CACLT,KADK,EAIa;MAFlBnB,OAEkB,uEAFC0B,cAED;MADlBzB,QACkB,uEADG0B,eACH;;SACXN,gBAAgBG,mBAAmBL,KAAnB,CAAhB,EAA2C,EAAEnB,gBAAF,EAAWC,kBAAX,EAA3C,CAAP;;;ACVF;;;AAGA,AAAO,SAAS4B,WAAT,CACLC,KADK,EAELX,KAFK,EAGLnB,OAHK,EAILC,QAJK,EAKL;MACMhB,WAAW2C,WAAWT,KAAX,EAAkBnB,OAAlB,EAA2BC,QAA3B,CAAjB;WACSf,MAAT,CAAgB;cACJ4C,MAAMC,QADF;YAEN,KAAK,CAFC;WAGPD,MAAME,QAAN;GAHT;;MAMMC,cAAcH,MAAMI,SAAN,CAAgB,YAAM;aAC/BhD,MAAT,CAAgB;gBACJ4C,MAAMC,QADF;cAEN,KAAK,CAFC;aAGPD,MAAME,QAAN;KAHT;GADkB,CAApB;;SAQO,YAAM;;aAEF7C,OAAT;GAFF;;;AC1BF;;;AAGA,AAAO,SAASgD,aAAT,CAA2BC,QAA3B,EAEU;MACTnB,gBAAgB,EAAtB;uBACiBoB,OAAOC,IAAP,CAAYF,QAAZ,CAAjB,kHAAwC;;;;;;;;;;;;QAA7BG,IAA6B;;kBACxBA,IAAd,IAAoBH,SAASG,IAAT,EAAatB,aAAjC;;;WAGO3B,QAAT,CAAmBC,KAAnB,EAA0C;QAChCS,OADgC,GACpBT,KADoB,CAChCS,OADgC;;QAElCwC,cAAgD,EAAtD;QACMC,YAAgD,EAAtD;QACIC,uBAAsCzB,aAAtC,CAAJ;QACItB,YAAqB,KAAzB;;;;;;;;;;;;UAEW4C,EAP6B;;UAQhCtC,WAAW,SAAXA,QAAW,CAACC,IAAD,EAAe;YAC1BA,SAASwC,QAAQH,EAAR,CAAb,EAA0B;iCACTG,OAAf;kBACQH,EAAR,IAAcrC,IAAd;gBACMD,QAAN,CAAeyC,OAAf;;OAJJ;kBAOYH,EAAZ,IAAkB,EAAEvC,gBAAF,EAAWC,kBAAX,EAAlB;gBACUsC,EAAV,IAAgBrB,UAAUkB,SAASG,EAAT,CAAV,EAAwBC,YAAYD,EAAZ,CAAxB,CAAhB;UACI5C,SAAJ,EAAe;;;0BAVA0C,OAAOC,IAAP,CAAYF,QAAZ,CAAjB,yHAAwC;;;;;4BAUvB;;;WAGV;YAAA,kBACGxB,KADH,EACa;8BACCyB,OAAOC,IAAP,CAAYG,SAAZ,CAAjB,yHAAyC;;;;;;;;;;;;cAA9BF,GAA8B;;oBAC7BA,GAAV,EAAcrD,MAAd,CAAqB0B,KAArB;cACIjB,SAAJ,EAAe;;OAJd;aAAA,qBAQM;oBACG,IAAZ;8BACiB0C,OAAOC,IAAP,CAAYG,SAAZ,CAAjB,yHAAyC;;;;;;;;;;;;cAA9BF,IAA8B;;oBAC7BA,IAAV,EAAcpD,OAAd;;;KAXN;;WAgBO6B,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyBA,aAAzB;SACO3B,QAAP;;;ACvDF;;;AAGA,AAAO,SAASqD,QAAT,CACLC,CADK,EAEL5C,OAFK,EAGuB;SACrB,YAAkB;QACnB;aACK4C,6BAAP;KADF,CAEE,OAAOhE,CAAP,EAAU;cACFA,CAAR;;GAJJ;;;;;;;AAYF,AAAO,SAASiE,cAAT,CAA+BC,CAA/B,EAAqCC,CAArC,EAAoD;MACrDD,MAAMC,CAAV,EAAa,OAAO,IAAP;;;MAGT,QAAOD,CAAP,yCAAOA,CAAP,OAAa,QAAjB,EAA2B,OAAO,KAAP;MACvB,QAAOC,CAAP,yCAAOA,CAAP,OAAa,QAAjB,EAA2B,OAAO,KAAP;;;MAGvB,CAACD,CAAD,IAAM,CAACC,CAAX,EAAc,OAAO,KAAP;;MAERT,OAAOD,OAAOW,mBAAP,CAA2BF,CAA3B,CAAb;MACIR,KAAKW,MAAL,KAAgBZ,OAAOW,mBAAP,CAA2BD,CAA3B,EAA8BE,MAAlD,EAA0D,OAAO,KAAP;;;;;uBAKhCX,IAA1B,kHAAgC;;;;;;;;;;;;QAArBY,GAAqB;;QAC1B,CAACH,EAAEI,cAAF,CAAiBD,GAAjB,CAAD,IAA0BJ,EAAEI,GAAF,MAAWH,EAAEG,GAAF,CAAzC,EAAiD,OAAO,KAAP;;SAE5C,IAAP;;;AC/BF;;;AAGA,AAAO,SAASE,WAAT,CACLjC,KADK,EAELkC,MAFK,EAGS;MACR9B,aAAaL,UAAUC,KAAV,CAAnB;;WAES7B,QAAT,CAAmBC,KAAnB,EAA0C;QAChCS,OADgC,GACVT,KADU,CAChCS,OADgC;QACvBC,QADuB,GACVV,KADU,CACvBU,QADuB;;QAEpChB,iBAAJ;QACIO,mBAAJ;QACIG,YAAqB,KAAzB;;QAEM2D,aAAaX,SAASU,MAAT,EAAiBrD,OAAjB,CAAnB;;QAEMW,aAA6B,EAAEX,gBAAF,EAAWC,kBAAX,EAAnC;;WAEO;YAAA,kBACGW,KADH,EACa;YACV2C,aAAaD,WAAW1C,KAAX,CAAnB;YACIjB,SAAJ,EAAe;YACT6D,QAAQ,CAACX,eAAeU,UAAf,EAA2B/D,UAA3B,CAAf;qBACa+D,UAAb;;;YAGIA,UAAJ,EAAgB;cACV,CAACtE,QAAL,EAAeA,WAAWsC,WAAWZ,UAAX,CAAX;cACXhB,SAAJ,EAAe;cACX6D,KAAJ,EAAWvE,SAASC,MAAT,CAAgBqE,UAAhB;SAHb,MAIO;cACDtE,QAAJ,EAAcA,SAASE,OAAT;qBACH,KAAK,CAAhB;;OAdC;aAAA,qBAkBM;oBACG,IAAZ;YACIF,QAAJ,EAAcA,SAASE,OAAT;mBACH,KAAK,CAAhB;;KArBJ;;WAyBO6B,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyBE,MAAMF,aAA/B;SACO3B,QAAP;;;AC9CF;;;AAGA,AAAO,SAASmE,QAAT,CACLtC,KADK,EAELuC,OAFK,EAGLL,MAHK,EAIS;MACR9B,aAAaL,UAAUC,KAAV,CAAnB;;WAES7B,QAAT,CAAmBC,KAAnB,EAA0C;QAChCS,OADgC,GACpBT,KADoB,CAChCS,OADgC;;QAEpCyC,YAAgD,EAApD;QACIC,UAAiC,EAArC;QACIiB,eAAwB,KAA5B;QACMnE,aAAyC,EAA/C;QACIE,WAAoB,KAAxB;QACIC,YAAqB,KAAzB;;QAEMiE,cAAcjB,SAASe,OAAT,EAAkB1D,OAAlB,CAApB;QACMsD,aAAaX,SAASU,MAAT,EAAiBrD,OAAjB,CAAnB;;QAEM6D,gBAAgB,SAAhBA,aAAgB,GAAM;UACtBF,gBAAgB,CAACjE,QAArB,EAA+B;uBACd,KAAf;YACMoE,aAAa,EAAnB;6BACiBzB,OAAOC,IAAP,CAAYG,SAAZ,CAAjB,kHAAyC;;;;;;;;;;;;cAA9BF,GAA8B;;qBAC5BA,GAAX,IAAiBG,QAAQH,GAAR,CAAjB;;kBAEQuB,UAAV;cACM7D,QAAN,CAAeyC,OAAf;;KARJ;;WAYO;YAAA,kBACGqB,UADH,EACkB;YACfC,MAAMJ,YAAYG,UAAZ,CAAZ;YACIpE,aAAa,CAACqE,GAAlB,EAAuB;;;mBAGZ,IAAX;YACMC,eAAmD,EAAzD;;;;;;;;;;;;cACW1B,EAPU;;cAQbgB,aAAaD,WAAWS,UAAX,EAAuBxB,EAAvB,CAAnB;cACI5C,SAAJ,EAAe;;;cACT6D,QAAQ,CAACX,eAAeU,UAAf,EAA2B/D,WAAW+C,EAAX,CAA3B,CAAf;qBACWA,EAAX,IAAiBgB,UAAjB;;cAEIA,UAAJ,EAAgB;gBACV,CAACd,UAAUF,EAAV,CAAL,EAAoB;kBACZtC,WAAW,SAAXA,QAAW,CAACC,IAAD,EAAe;oBAC1BA,SAASwC,QAAQH,EAAR,CAAb,EAA0B;0BAChBA,EAAR,IAAcrC,IAAd;iCACe,IAAf;;;eAHJ;wBAOUqC,EAAV,IAAgBhB,WAAW,EAAEvB,gBAAF,EAAWC,kBAAX,EAAX,CAAhB;kBACIN,SAAJ,EAAe;;;;gBAEb6D,KAAJ,EAAWf,UAAUF,EAAV,EAAcrD,MAAd,CAAqBqE,UAArB;gBACP5D,SAAJ,EAAe;;;yBACF4C,EAAb,IAAmBE,UAAUF,EAAV,CAAnB;;;;gBApBJ,sBAAiByB,GAAjB,yHAAsB;;;;;;;;;;;;;;;;;YAyBhBE,eAAezB,SAArB;oBACYwB,YAAZ;;;;8BAIiB5B,OAAOC,IAAP,CAAY4B,YAAZ,CAAjB,yHAA4C;;;;;;;;;;;;cAAjC3B,IAAiC;;cACtC,CAAC0B,aAAa1B,IAAb,CAAL,EAAuB2B,aAAa3B,IAAb,EAAiBpD,OAAjB;;YAErBQ,SAAJ,EAAe;;mBAEJ,KAAX;;OA3CG;aAAA,qBA+CM;oBACG,IAAZ;8BACiB0C,OAAOC,IAAP,CAAYG,SAAZ,CAAjB,yHAAyC;;;;;;;;;;;;cAA9BF,IAA8B;;cACnCE,UAAUF,IAAV,CAAJ,EAAmBE,UAAUF,IAAV,EAAcpD,OAAd;;;KAlDzB;;WAuDO6B,IAAT,GAAgB,IAAhB;WACSC,aAAT,GAAyB,EAAzB;SACO3B,QAAP;;;ACvFF;;;AAGA,IAAa6E,KAAb;iBAGevD,KAAb,EAAuBwD,SAAvB,EAAmD;;;SAC5CxD,KAAL,GAAaA,KAAb;;;;;;;;;;2BAMMA,KAVV,EAUoBwD,SAVpB,EAUoE;;;;;;;;;4BAMzDxD,KAhBX,EAgBqBwD,SAhBrB,EAgBgD;;;;;;;;AAMhD,AAAO,SAASC,cAAT,CAA4BC,WAA5B,EAAwE;SACtEpD,UAAU,gBAA0C;QAAvClB,OAAuC,QAAvCA,OAAuC;QAA9BC,QAA8B,QAA9BA,QAA8B;;QACnDmE,YAA4B,EAAEpE,gBAAF,EAAWC,kBAAX,EAAlC;QACIhB,iBAAJ;QACIO,mBAAJ;;WAEO;YAAA,kBACGoB,KADH,EACa;qBACHA,KAAb;YACI,CAAC3B,QAAL,EAAe;qBACF,IAAIqF,WAAJ,CAAgB1D,KAAhB,EAAuBwD,SAAvB,CAAX;;eAEKnF,SAASC,MAAT,CAAgB0B,KAAhB,EAAuBwD,SAAvB,CAAP;OANG;aAAA,qBASM;eACFnF,SAASE,OAAT,CAAiBK,UAAjB,EAA6B4E,SAA7B,CAAP;;KAVJ;GALK,CAAP;;;ACOF;;;AAGA,AAAO,IAAMG,cAAc;MAAA,kBAAU;CAA9B;;;;;;;;;;;;;;;"}